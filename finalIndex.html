<!DOCTYPE html>
<html>
    <head>
        <style>
            html,body{
                height: 100%;
                display: grid;
                overflow: hidden;
                background: #000;
            }
            #a{
                border-radius: 10px;
                margin: auto;
            }
        </style>
    </head>
    <body>
        <canvas id=a></canvas>
    </body>
    <script>

const windows = window
const documents = document
const math=Math
const PI = math.PI
const timer = performance
const l = windows.localStorage

Rand=a=>math.random()*a
RandInt=a=>Rand(a)|0;
RandIntBetween=(a,b)=>a+RandInt(b-a+1);
Distance=(a,b)=>math.hypot(a,b);
CollisionRect=(a,b)=>(a.x+a.w>b.x&&b.x+b.w>a.x&&a.y+a.h>b.y&&b.y+b.h>a.y)?1:0
Max=(a,b)=>a>b?a:b;
Min =(a,b)=>(a<b)?a:b;
IntToString=a=>a.toString()
Pad=a=>a.padStart(4,"0");
SlopeY=(a,b,k=-20)=>a*k+b

localSet=(e,a)=>l.setItem(e,a)
localGet=e=>l.getItem(e)

GetCanvas=a=>documents.getElementById(a)
GetContextAlpha=a=>a.getContext('2d',{
    alpha: false,
    desynchronized: true
})
GetContext=a=>a.getContext('2d')
CreateElement=a=>documents.createElement('canvas')

// UI frame size
let innerWidth,canvasWidth,canvasHeight,mouseCanvas,resizeWindow,tw,th;

//test speed 
let count =1
let canvas = GetCanvas('a')
let ctx = GetContextAlpha(canvas)
let GamePlayObject = [],BackgroundMoveObject=[]

let BadItemImage  = []
let GoodItemImage = []

// inputs controls
let key= {},key1={},checkButton=[]
let keyStopRestartMute=['r','m','p']
// initial key dict
keyStopRestartMute.forEach(e=>key1[e]=0)

console.log(key1)

InitailLoopDict=(k,initialValue)=>{
    for (const i in k)k[i]=initialValue
    return k
}
onblur=e=>key1=InitailLoopDict(key1,0)
onfocus=e=>key1.p=1

onmousedown=e=>{
    // let as = e.button==0?e.type=="mouseup"?"b":"a":"c"
    if(!e.button){
        e.pageX>innerWidth/2?key.s=1:key.a=1
        let x= e.clientX - mouseCanvas.left
        let y = e.clientY - mouseCanvas.top
        let h=w=1
        console.log(x/2,y/2)
        checkButton.forEach((e,i)=>{
            if(CollisionRect(e,{x:x/2,y:y/2,w,h})){
                key1[keyStopRestartMute[i]]=!key1[keyStopRestartMute[i]]
                console.log("onmousedown and up",key1)
            }
            console.log("onmousedown",CollisionRect(e,{x:x/2,y:y/2,w,h}))
        })
    }
    console.log("onmousedown and up",checkButton[0])
    console.log("onmousedown and up",key1)
}
onmouseup=e=>!e.button?key=InitailLoopDict(key,0):0;
ontouchstart=e=>{
    var x = e.changedTouches[0].pageX;
    if(x>innerWidth/2){
        key.s=1
    }else{
        key.a=1
    }
}

ontouchend=e=>key=InitailLoopDict(key,0);

// p:pause , R:restart , M:mute sound
let adfdadsf = [2,4,8,16,32]
let index = 1
onkeydown=e=>{
    let i = e.key
    if(keyStopRestartMute.includes(i))key1[i]=!key1[i]
    else key[i]=1;
    if(i=="m"){
        
        count=adfdadsf[index]
        index++
        console.log(count)
    }
}
onkeyup=e=>key[e.key]=0

// Canvas resizing
const resize = () => {
    const unit = 32,iw=windows.innerWidth,ih=windows.innerHeight;
    const size = Min((Min(iw, ih) / unit)|0, 24);
    tw = canvasWidth=canvas.width = size * unit;
    th = canvasHeight=canvas.height = size * unit + size*4;
    ctx.imageSmoothingEnabled = false;
    tw = canvasWidth/2
    th = canvasHeight/2
    innerWidth=iw
    mouseCanvas = canvas.getBoundingClientRect();
    checkButton=[]
    resizeWindow=0
};
onresize=e=>resize()
resize()


// draw rect 

// Colour adjustment function
// Nicked from http://stackoverflow.com/questions/5560248

shadeColor=(color, percent)=>{
    color = color.substr(1);
    var num = parseInt(color, 16),
      amt = Math.round(2.55 * percent),
      R = (num >> 16) + amt,
      G = (num >> 8 & 0x00FF) + amt,
      B = (num & 0x0000FF) + amt;
    return '#' + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 + (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 + (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
}
rect1=(ctx,x,y,w,h,c="red",r=5,a=0)=>{
    ctx.save()
    ctx.fillStyle=c
    ctx.strokeStyle=c
    ctx.beginPath()
    ctx.miterLimit=30
    ctx.lineWidth=2
    ctx.moveTo(x, y)
    ctx.lineTo(x+w, y)
    ctx.arcTo(x+w+r, y, x+w+r, y+r, r)
    ctx.lineTo(x+w+r,y+h+r)
    ctx.arcTo(x+w+r,y+h+r+r,x+w,y+h+r+r,r)
    ctx.lineTo(x,y+h+r+r)
    ctx.arcTo(x-r,y+h+r+r,x-r,y+h+r,r)
    ctx.lineTo(x-r,y+r)
    ctx.arcTo(x-r,y,x,y,r)
    a?ctx.fill():ctx.stroke()
    ctx.restore()
}
// Game darw  Wall
CreateWall=color=>{
    var fontCanvas = CreateElement()
    var fontCtx = GetContext(fontCanvas),ww,hh
    ww=hh=fontCanvas.width=fontCanvas.height=32
    fontCtx.scale(2,2);
    fontCtx.fillStyle=shadeColor(color,-10);
    fontCtx.fillRect(0,0,ww,hh);
    ww = ww/6,hh=hh/6
    let x=y=c=0,gap=0
    for(var i=0;i<9;i++){
        fontCtx.fillStyle=shadeColor(color,RandInt(3))
        let appendWidth= RandInt(ww/2)
        fontCtx.fillRect(x+gap,y,ww+appendWidth,hh)
        //fontCtx.strokeRect(x+oldWidth,y,ww+tt,hh)
        gap=appendWidth
        if(c==2){
            y+=hh
            x=c=0
        }else{
            x+=ww
            c++
        }
    }
    var imagea = new Image();
    imagea.src = fontCanvas.toDataURL();
    return imagea;
}
CreateItem=(stroke,color,type,angle=0)=>{
    var fontCanvas = CreateElement()
    var fontCtx = GetContext(fontCanvas)
    fontCanvas.width=fontCanvas.height=64
    let halfh = 32
    fontCtx.translate(halfh,halfh);
    fontCtx.rotate(PI*angle);
    fontCtx.translate(-halfh,-halfh);
    rect1(fontCtx,type.x,type.y,type.w,type.h,color,type.r,stroke)
    fontCtx.setTransform(1, 0, 0, 1, 0, 0);
    var imagea = new Image();
    imagea.src = fontCanvas.toDataURL();
    return imagea;
}
CreateItemDraw=(a,frames)=>{
    //     [1,"#00000",[64,32,-64,-64,30],[.5,,,1],.1]
    let framesArray = []
    for(var i=0;i<frames;i++){
        framesArray.push(CreateItem(a[0],shadeColor(a[1],1),{
            x:a[2][0]+i*a[3][0],
            y:a[2][1]+i*a[3][1],
            w:a[2][2]+i*a[3][2],
            h:a[2][3]+i*a[3][3],
            r:a[2][4]+i*a[3][4]},i*a[4]))
    }
    return framesArray
}

class Vector{
    constructor(x,y,w=32,h=32){
      this.x = x
      this.y = y
      this.h= h
      this.w= w
      this.maxWidth=w
    }
    set(v){
      this.x = v.x
      this.y = v.y
      return this;
    }
    add(v){
      this.x+=v.x
      this.y+=v.y
    }
    addOne(v){
      this.x+=v
      this.y+=v
    }
    addX(v){
        this.x+=v.x
    }
    zero(){
      this.x=this.y=0
    }
    substract(v){
      this.x -= v.x
      this.y -= v.y
      return this;
    }
    multiply(s){
      let A = s/Distance(this.x,this.y)
      this.x *= A
      this.y *= A
    }
    dot(a){
      this.x*=a
      this.y*=a
      return this
    }
    clone(){
      return new Vector(this.x,this.y,this.w,this.h)
    }
    norm(v){
      let tx = v.x-this.x,ty =v.y-this.y
      let dist = Distance(tx,ty)
      return new Vector(tx/dist,ty/dist)
    }
    size(v,th){
        this.w =(this.maxWidth-v.w)/(th-v.y)*this.w
        //return new Vector(this.x,this.y,this.w*this.y,this.h)
    }
    less(mw,mh){
      return this.x<mw||this.y<mh
    }
    collisionRect(a){
        return CollisionRect(this,a)
    }
}
// initial game config
let PlayerConfig={
    speed:1,
    maxSpeed:32,
    targetPos:new Vector(tw/2,-th,2,2)
}
class GameObject{
    constructor(x,y,o,w=32,h=32){
      //poisition
      this.pos = new Vector(x,y,w,h)
      this.VectorXY = new Vector(0,0,w,h)
      this.w = w
      this.h = h
      this.p = o
      this.frameTime = 0
      GamePlayObject.push(this)
    }
    render(ms){
        this.draw()
        this.update(ms)
    }
    draw(){}
    update(ms){}
    remove(){
      GamePlayObject.splice(GamePlayObject.indexOf(this),1);
    }
}
class Faller extends GameObject{
    constructor(x,y,w,h,f){
        super(x,y,1,w,h)
        this.D = 0 // dierction 0 1 2 ,decide the image
        this.frames = f
        this.tw =tw
        this.life = 100
    }
    draw(){
        rect1(ctx,this.pos.x,this.pos.y,this.w,this.h,"#5f6",5,1)
    }
    move(ms){
        let move = ms*200
        this.VectorXY.zero()
        // keyboard in or mouse in
        if(key.a||key.A||key.z||key.Z){
            this.VectorXY.substract(new Vector(move,0))
            this.D=1
            console.log(this.D)
        }//left

        if(key.S||key.s||key.X||key.x){
            this.VectorXY.add(new Vector(move,0))
            this.D=2
        }//right
        this.oldPos = this.pos.clone()
        this.pos.addX(this.VectorXY)
        if(this.pos.x>tw-tw/4.5){
            this.pos = this.oldPos.substract(this.VectorXY)
        }
        if(this.pos.x<tw/8.5){
            this.pos = this.oldPos.substract(this.VectorXY)
        }
    }
    update(ms){
        this.move(ms)
        GamePlayObject.forEach(e=>{
            if(e.p>=2){
                if(e.pos.collisionRect(this.pos)){
                    this.life-=20
                    this.life=Max(this.life,0)
                    // blood effect
                    this.life<=0?this.destory():0
                }
            }
        })
    }
    destory(){
        this.remove()
    }
}
class Blood extends GameObject{
    constructor(x,y,w,c){
        super(x,y,0,w,w)
        this.dx = x+(Rand(1)<.5?3:-3)*Rand(3)*.5
        this.dy = y+(Rand(1)<.5?3:-3)*Rand(3)*.5
        this.c = c
    }
    draw(){
        rect1(ctx,this.x,this.y,1,1,this.c,this.w,1)
    }
    update(ms){

        this.frameTime+=ms
        this.frameTime>3?this.remove():0
        this.dy -= ms*10
        this.x -= this.dx
        this.y -= this.dy
        this.w -= .05
    }
}
class cloud extends GameObject{
    constructor(x,y,w,h){
        super(x,y,0,w,h)
        this.initialX = this.x
        this.initialY = this.y
    }
    draw(){

    }
    update(ms){

    }
    destory(){
        this.remove()
    }
}
class Item extends GameObject{
    constructor(x,y,w,h,f,type){
        super(x,y,type,w,h)
        this.initialX = this.pos.x
        //animation
        this.frameArray = f
        this.curFrame = f[0]
        this.frameTime = 0
        this.th = th
    }
    draw(){
        //rect1(ctx,this.pos.x,this.pos.y,1,1,"#35fa12",this.w,1)
        ctx.drawImage(this.curFrame,this.pos.x,this.pos.y,this.pos.w,this.pos.h)
    }
    update(ms){
        let l = this.frameArray.length
        this.frameTime ++
        this.curFrame = this.frameArray[(this.frameTime%l)|0]
        let gap = 1
        let targetX  = this.initialX+gap
        let targetPosX = this.pos.x>=tw/2?Min(tw-tw/7,this.initialX)-this.w:Max(tw/4,targetX)
        this.VectorXY = this.pos.norm(new Vector(targetPosX,-this.th))
        this.VectorXY.dot(index)
        this.pos.add(this.VectorXY)
        this.pos.w -= (this.pos.maxWidth)/Distance(0,this.th*2)*this.pos.y*ms
        this.pos.w = Max(this.pos.w,this.pos.maxWidth/2)
        //this.pos.size({y:-this.th,w:32},this.th)
        GamePlayObject.forEach(e=>{
            if(e.p==3){
            if(e.pos.collisionRect(this.pos)){
                if(e.p==2){

                }
            }
            }
        })
        if(this.pos.less(0,-this.pos.h)){
            this.destory()
        }
        this.frameTime = this.frameTime>l*2?0:this.frameTime
    }
    destory(){
        //new Item(this.initialX,this.th,this.w,this.h,this.frameArray,this.p)
        this.remove()
    }
}
class BuildingWall{
    constructor(x,y,w,h,c="#bb8888"){
        this.pos = new Vector(x,y,w,h)
        this.VectorXY=this.pos.clone()
        this.initialX = x
        this.initialY = canvasHeight/2
        this.f = CreateWall(c)
        this.th = th
        BackgroundMoveObject.push(this)
    }
    render(ms){
        this.draw()
        this.update(ms)
    }
    draw(){
        ctx.drawImage(this.f,this.pos.x,this.pos.y,this.pos.w,this.pos.h)
    }
    update(ms){
        this.VectorXY = this.pos.norm(new Vector(this.pos.x,-this.th,1,1))
        
        //this.VectorXY.dot(Min(PlayerConfig.speed,PlayerConfig.maxSpeed))
        this.VectorXY.dot(count)
        PlayerConfig.speed = this.VectorXY.y
        
        if(this.pos.less(0,-this.pos.h+count)){
            //level up
            if(key1.m){
                this.newlevel()
            }
            this.loop()
        }
        this.pos.add(this.VectorXY)
    }
    loop(){
        this.pos.set({x:this.initialX,y:this.th})
    }
    newlevel(){
        this.f = CreateWall("#1AF1F6")
    }
}
//background view 1 ~ 2
background=_=>{
    var fontCanvas = CreateElement()
    var fontCtx = GetContext(fontCanvas)
    fontCanvas.width=tw
    fontCanvas.height=th
    var radialGradient = fontCtx.createRadialGradient(tw,0, 40, tw, 0, th/10);
    radialGradient.addColorStop(.3, '#FFE261');
    radialGradient.addColorStop(.7, '#F3CD05');
    radialGradient.addColorStop(.8, '#F49F05');
    radialGradient.addColorStop(1, '#FFF8C8');
    fontCtx.beginPath()
    fontCtx.fillStyle = radialGradient;
    fontCtx.fillRect(0, 0, tw, th);
    //fontCtx.globalCompositeOperation = "screen"
    //GameObjectTest=[]
    for(var i=0;i<tw;i+=40){
        let height = RandIntBetween(th/4,th-th/8)
        let color = shadeColor("#36688D",RandIntBetween(-20,20))
        rect1(fontCtx,RandIntBetween(0,tw),th-height,RandInt(64),height,color,8,1)
    }
    var imagea = new Image();
    imagea.src = fontCanvas.toDataURL();
    return imagea;
}
let back = background()

//building 
BackgroundView=_=>{
    ctx.drawImage(back,0,0,tw,th)
}

BuildingWallInitial=()=>{
    for(let j =0;j<th/28;j++){
        for (let i = 0; i < tw/32; i++) {
            new BuildingWall(32*i,32*j,32,32)
        }
    }
}
// UI Bar textfield
TextField=(str,x,y,size,color="#fff")=>{
    ctx.fillStyle=color
    ctx.font=size+"px Impact"
    ctx.fillText(str,x,y)
}
bar=(x,y,h,live,ml,str)=>{
    ctx.save()
	let cy = h/ml*live,ty=y
    rect1(ctx,x,y+=(h-cy),5,cy,"#1fc",5,1)
    rect1(ctx,x,ty,5,h,"#000")
 	for(var i=0;i<live;i+=25){
    	rect1(ctx,x,ty+(h-h/ml*i),8,1,"#a11",1,1)
    }
    ctx.fillStyle="#0F0"
    ctx.font="20px Impact"
    ctx.fillText(str,x-11,ty+h+10*2)
    ctx.restore()
}
ScaleLine=(x,y,gh,h=200)=>{
    ctx.save()
    ctx.beginPath()
    ctx.lineWidth = 3
    for(var i=0,c=0;i<=h;i+=gh*2,c++){
        ctx.strokeStyle="#fff"
        if(c==5)rect1(ctx,x-gh/2,y+i,gh,gh,"#bb8",5,1)
        else rect1(ctx,x+gh/2,y+i,-gh,gh)
        ctx.stroke()
    }
    ctx.restore()
}
let adf= 0
GameUIView=ms=>{
    ctx.save()
    ctx.beginPath()
    let ci =1,firstLineY=20,secondLineY=80,sizeW=100
    for(var k in keyStopRestartMute){
        ctx.globalCompositeOperation = "lighten"
        ctx.globalAlpha = Max(1-key1[keyStopRestartMute[k]],.5)
        let x = tw-20*ci-5,y=firstLineY,h=12,w=18
        resizeWindow?0:checkButton.push({x,y:y-10,w,h})
        ctx.fillText(ci-1?ci-2?"â¯ï¸":"ðŸŽ§":"ðŸ ",x,y)
        ci++
    }
    ctx.restore()
    resizeWindow=1
    ctx.save()
    ctx.beginPath()
    ctx.fillStyle="#fff"
    // ctx.drawImage(sdfsdf.E,80,50,64,64)
    // ctx.drawImage(sdfsdf.E,80,50,64,64)
    ctx.font="30px Impact"
    let score = Pad(IntToString(Min(25,9999)))
    ctx.fillText(score,tw-firstLineY*3.5,secondLineY-firstLineY)
    //ctx.strokeRect(tw-firstLineY*3.1,secondLineY-40,50,25)
    TextField("Meter",10,firstLineY+5,15)
    TextField(((adf*10*ms)|0)+"  /m",15,firstLineY*2,10)
    TextField("G-Speed",10,firstLineY*3,15)
    TextField(((count)|0)+"  /g",15,firstLineY*4,10)
    ScaleLine(20,th/2,10,sizeW)
    bar(tw-firstLineY,secondLineY,40,sizeW,sizeW,"ðŸ§¡")
    //bar(tw-firstLineY,secondLineY,40,sizeW,sizeW,"ðŸ¥¶")
    //ctx.globalCompositeOperation="exclusion"
    //rect1(ctx,25,th/2+adf,2,2,"#b88",2,1)
    //rect1(ctx,32,32,32,32,"#fff",16,1)
    // x,y  // x-(-w)-8
    ///rect1(ctx,32,16,-32,-32,"#333",16,1)
    //ctx.drawImage(wallImage,32,32,32,32)
    adf += 1
    adf = Min(sizeW,adf)
    ctx.restore()
}
let iron_ball_shake = CreateItemDraw([1,"#111111",[64,32,-64,-64,30],[0,0,0,0,0],.5],20)
    let long_wall = CreateItemDraw([1,"#111111",[16,16,32,-38,16],[0,0,0,0,0],0],1)
    let iron_ball_rotate = CreateItemDraw([0,"#111111",[64,32,-64,-64,30],[0,0,0,0,0],.5],20)
    let fix_arrow = CreateItemDraw([0,"#111111",[64,32,-64,-64,32],[0,-1,0,0,1],0],30)
    let ciclre = CreateItemDraw([0,"#111111",[64,32,-64,-64,32],[0,-1,0,0,1],.1],30)
    let fansa = CreateItemDraw([1,"#111111",[64,0,-64,-64,64],[0,0,0,0,0],.1],10)
    let adsf = CreateItemDraw([0,"#111111",[64,32,-64,-32,32],[0,-1,0,-1,-.1],.1],30)
    BadItemImage = [iron_ball_shake,long_wall,iron_ball_rotate,fix_arrow,ciclre,fansa,adsf]

AppearArry = _=>{
    // -----------------|
    let randomnumbers = new Set, ans;
    while (randomnumbers.size < 6) {    
        randomnumbers.add(RandInt(6));
    }
    return ans = [...randomnumbers]
}
AppearDist=a=>a.join("").replace("0","#0#").split("#").filter(e=>e)
WallResize=a=>a.map((e)=>e!="0"?e.length*tw/8:tw/6)

ItemGenerator=l=>{
    // level linear up
    // bad item appear 

    let badIt = [1,2,3,4,5,6]
    let randAppearNum = Min(RandInt(l),5)
    let randAppearChance=AppearArry()
    let maxRandBadImageLength = Min(badIt.length,l)
    // level 3 6 9
    //if(!(index%3)&&index){
    if(1){
        let curX = 0
        let appearLength = AppearDist(randAppearChance)
        WallResize(appearLength).forEach((e,i)=>{
            if(appearLength[i]!="0"){
                new Item(curX,th+32,e,32,BadItemImage[1],2)
            }else{
                curX+=tw/6
            }
            curX+=e
        })
    }
    // level 1 4 7
    // level 2 5 8 
    // randAppearChance.forEach((e,i)=>{
    //     if(e&&e<=randAppearNum){
    //         if(index==3){
    //             AppearDist(randAppearChance)
    //             new Item(i*tw/6,th+32,32,32,BadItemImage[1],2)
    //         }
    //         // let item = RandInt(maxRandBadImageLength)
    //         // if(item==2){
    //         //     new Item(i*tw/6,th+32,32,32,BadItemImage[item],2)
    //         // }else{
    //         //     new Item(i*tw/6,th+32,32,32,BadItemImage[item],2)
    //         // }
    //     }
    // })
    // for(var i=0;i<=randAppearNum;i++){
    //     let maxRandBadImageLength = Min(badIt.length,l)
    //     let randX = Rand(tw-32)
    //     upGap = randX
    //     new Item(i*64,th+32,32,32,BadItemImage[RandInt(maxRandBadImageLength)],2)
    // }
}
GameWorldInit=l=>{
    GamePlayObject=[]
    BackgroundMoveObject=[]
    BuildingWallInitial()
    // 
    // let iron_ball_shake = CreateItemDraw([0,"#f1f380",[64,32,-64,-64,30],[0,0,0,0,0],.5],20)
    // let long_wall = CreateItemDraw([0,"#f1f380",[16,16,32,-38,16],[0,0,0,0,0],0],1)
    // let iron_ball_rotate = CreateItemDraw([0,"#f1f380",[64,32,-64,-64,30],[0,0,0,0,0],.5],20)
    // let fix_arrow = CreateItemDraw([0,"#f1f380",[64,32,-64,-64,32],[0,-1,0,0,1],0],30)
    // let ciclre = CreateItemDraw([0,"#f1f380",[64,32,-64,-64,32],[0,-1,0,0,1],.1],30)
    // let fansa = CreateItemDraw([1,"#f1f380",[64,0,-64,-64,64],[0,0,0,0,0],.1],10)
    // let adsf = CreateItemDraw([0,"#f1f380",[64,32,-64,-32,32],[0,-1,0,-1,-.1],.1],30)
    
    BadItemImage = [iron_ball_shake,long_wall,iron_ball_rotate,fix_arrow,ciclre,fansa,adsf]
    new Faller(tw/2,th/8,tw/16,th/16,10)

    
    // for(var i =0;i<50;i++){
    //     new Item(i*32+RandInt(i*32),th+RandInt(i*32),32,32,BadItemImage[RandInt(BadItemImage.length)],2)
    // }
    
}
// speed max 32 
let lastUpdate = timer.now();
let distanceY = 0
Update=()=>{
    const now = timer.now();
    const deltaMs = now - lastUpdate;
    const delta = deltaMs / 1000;
    lastUpdate = now;
    BackgroundView()
    // if playing >
    if(1){
        ctx.save()
        ctx.strokeStyle="#FF1"
        ctx.fillStyle="#555"
        ctx.beginPath()
        let tempSize = 32
        //ctx.strokeRect(tw/4-tempSize/,th/8,tempSize,tempSize)
        ctx.moveTo(tw/8,0)
        ctx.lineTo(0,th)
        ctx.lineTo(tw,th)
        ctx.lineTo(tw-tw/8,0)
        ctx.fill()
        //ctx.stroke()
        ctx.clip()
        BackgroundMoveObject.forEach(e=>{
            e.render(delta)
        })
        
        GamePlayObject.forEach(e=>{
            if(e.pos.y<=th){
                e.render(delta)
            }else{
                e.update(delta)
            }
        })
        ctx.restore()
        distanceY+=index
        if(distanceY>=128*2){
           ItemGenerator(index)
           console.log(index)
           // ItemGenerator(level)
           distanceY=0
        }
        GameUIView(delta)
    }else{
        // start view
    }
}
MainLoop=_=>{
    ctx.clearRect(0,0,canvasWidth,canvasHeight)
    ctx.save()
    ctx.scale(2,2)
    tw = canvasWidth/2
    th = canvasHeight/2
    Update()
    ctx.restore()
    requestAnimationFrame(MainLoop)
}
GameWorldInit()
MainLoop()
</script>
</html>